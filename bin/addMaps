#!/bin/env python 

import sys, os
import liteMap
import mapPCG, mapPCGFilter, mapProjector, noiseInverse, preconditioner
import trace
import actDict #Eventually replace with something local
from scripts import mobyScriptTools3000 as mst3k #Eventually replace with something local

paramFile = sys.argv[1]
params = actDict.ACTDict()
params.read_from_file(paramFile)

trace.setLevel("flipper.pcg", params["trace"])

for field in params["fields"]:
    for mapNumber in [0,1]:
        if params["outPath"] == None:
            outPath = "%s_%d" % (field, mapNumber)
        else:
            outPath = params["outPath"]
        if not os.path.exists(outPath):
            os.makedirs(outPath)
        
        print "Reading in the submaps and computing filters"
        baseDir = params["baseDir"]
        
        rising0 = "%s/%s%s.fits"%(baseDir,'rising/coaddedWeighted_0_', field)
        rising1 = "%s/%s%s.fits"%(baseDir,'rising/coaddedWeighted_1_', field)
        setting0 = "%s/%s%s.fits"%(baseDir,'setting/coaddedWeighted_0_', field)
        setting1 = "%s/%s%s.fits"%(baseDir,'setting/coaddedWeighted_1_', field)
        
        if mapNumber == 1:
            mr = liteMap.liteMapFromFits(rising1)
            mr.name = "rising1"
            ms = liteMap.liteMapFromFits(setting1)
            ms.name = "setting1"
            _mr = liteMap.liteMapFromFits(rising0)
            _mr.name = "rising0"
            _ms = liteMap.liteMapFromFits(setting0)
            _ms.name = "setting0"
        elif mapNumber == 0:
            mr = liteMap.liteMapFromFits(rising0)
            mr.name = "rising0"
            ms = liteMap.liteMapFromFits(setting0)
            ms.name = "setting0"
            _mr = liteMap.liteMapFromFits(rising1)
            _mr.name = "rising1"
            _ms = liteMap.liteMapFromFits(setting1)
            _ms.name = "setting1"
        msum = mr.copy()
        msum.data[:] = 0.
        
        assert( mr.data.shape == ms.data.shape )
        
        p2dr = noiseInverse.noisePowerFromMobyMaps(mr, _mr)
        p2ds = noiseInverse.noisePowerFromMobyMaps(ms, _ms)
        p2dr.createKspaceMask(verticalStripe=[-200,200],slantStripeLxLy=[-350,270],\
                smoothingRadius=10,apodizeWithGaussFWHM=None)
        p2ds.createKspaceMask(verticalStripe=[-200,200],slantStripeLxLy=[350,270],\
                smoothingRadius=10,apodizeWithGaussFWHM=None)
        
        trace.issue("flipper.pcg", 2, "Adding maps and data to the pcg")
        mpcg = mapPCG.pcg( filterClass = None, filterParams = None ) 
        mpcg.tolerance = params["pcgTolerance"]
        # We might want to put in a divideByWeight preconditioner, but this will not work
        # well in the areas which have data from only one of the maps (i.e. the null crosses)
        mpcg.addMap(msum, "sky")
        mpcg.addTOD(mr, {"sky": mapProjector.mapProjector()}, filter = mapPCGFilter.mapNoiseFilter(mr, p2dr))
        mpcg.addTOD(ms, {"sky": mapProjector.mapProjector()}, filter = mapPCGFilter.mapNoiseFilter(ms, p2ds))
        
        trace.issue("flipper.pcg", 2, "Setting up PCG")
        mpcg.setup()
        
        #Iterate PCG
        i=0
        trace.issue("flipper.pcg", 2, "Stepping PCG")
        while (i < params['maxIter'] and not mpcg.step()):
            trace.issue("flipper.pcg", 3,  "Iteration %d: Convergence is %e. Target = %e." % \
              (i, mpcg.convergence(), params['pcgTolerance']) )
            if params['saveAllIterations']:
                mst3k.PCGWriteMap( mpcg, outPath, iter = i )
            i += 1
        mst3k.PCGWriteMap(mpcg, outPath)
        
