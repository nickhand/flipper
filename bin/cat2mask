#!/usr/bin/env python

from moby import *
from scipy import *
from scipy.signal import *
import numpy
from numpy.fft import *
import scipy
import sys, os
import actDict

def main():
    
    paramFile = sys.argv[1]
    params = actDict.ACTDict()
    params.read_from_file(paramFile)
    m = Map.read(params['map'])# first read in a map

    mask = m.copy()
    mask.data[:]= 0.0
    
    f = file(params['catalog'])# next the ascii catalog
    g = open(params['output_catalog'],'w')# open an output file

    print "making holes"
    flux_max = params['flux_max']
    makeHoles(f, mask, flux_max)
    mask.display()

    print 'now convolving'
    mt=convolveWithGaussian(mask)
    mt.display()

    print 'normalize by noize rms'
    sigman =  params['noise_rms']
    nsigma =  params['detection_threshold']
    
    mask = mt.copy()
    mask.data[:]= mask.data[:]/sigman
    ##mask.data[:]= numpy.floor(mask.data[:]/nsigma)
    mask.display(frame=1)
    ind1 = np.where( mask.data[:] > nsigma )
    ind0 = np.where( mask.data[:] <= nsigma )
    mask.data[ind1] = 0.0
    mask.data[ind0] = 1.0
  
    mask.display(frame=2)
    print 'writing mask'
    mask.write(params['mask'])

    
def makeHoles(catalog, mask, flux_max):
    """
    @brief (C)  from Yen-Ting
    """
    f=catalog
    
    Nx = mask.cmap.ncol
    Ny = mask.cmap.nrow
    pixScaleX = numpy.abs(mask.lon1-mask.lon0)/Nx*numpy.pi/180.\
                *numpy.cos(numpy.pi/180.*0.5*(mask.lat0+mask.lat1))
    pixScaleY = numpy.abs(mask.lat1-mask.lat0)/Ny*numpy.pi/180.
    pix_area = pixScaleX * pixScaleY
    
    mJ2uK = 2.73*1.e+6/(pix_area*1.050869e+09*1e3)  #mJy to uK conversion for 145GHz
    
    lines = f.readlines()
    for line in lines:
        line = line[:-1]  # remove new line character
        fields = line.split()  # split on white space
        x = float(fields[0])    # specify which field is the ra
        y = float(fields[1])    # specify which field is the dec
        flux = float(fields[2])   # specify which field is the flux
        if x>mask.lon0 and x<mask.lon1 and y>mask.lat0 and y<mask.lat1 and flux>flux_max:
            # select sources in the maps and a bogus flux limit
            k,j = mask.sky2pix(x*math.pi/180.,y*math.pi/180.)
            # now j is x pixel coordinate, k is y pixel coordinate
            mask.data[ k,j]=1.0*flux*mJ2uK

        
def convolveWithGaussian(map,fwhm=1.4,nSigma=5.0):
    """
    @brief (C) modified version of convolveWithGaussian in flipper
    @brief convolve a map with a Gaussian beam (real space operation)
    @param fwhm Full Width Half Max in arcmin
    @param nSigma Number of sigmas the Gaussian kernel is defined out to.
    """
    
    fwhm *= numpy.pi/(180.*60.)
    Nx = map.cmap.ncol
    Ny = map.cmap.nrow
    pixScaleX = numpy.abs(map.lon1-map.lon0)/Nx*numpy.pi/180.\
                        *numpy.cos(numpy.pi/180.*0.5*(map.lat0+map.lat1))
    pixScaleY = numpy.abs(map.lat1-map.lat0)/Ny*numpy.pi/180.


    print pixScaleX, pixScaleY
    sigmaY = fwhm/(numpy.sqrt(8.*numpy.log(2.))*pixScaleY)
    sigmaX = fwhm/(numpy.sqrt(8.*numpy.log(2.))*pixScaleX)
    smMap = map.copy()
    
    data = gaussianSmooth(map.data,sigmaY,sigmaX,nSigma=nSigma)
    smMap.data[:,:] = data[:,:]
    del data
    return smMap

def gaussianSmooth(im, sigmaY, sigmaX,nSigma=5.0) :
    """
    @brief (C) modified version of gaussianSmooth in flipper
    @brief smooths an image with a Gaussian given sigmas in x and y directions.
    @param sigmaY standard deviation of Gaussian in pixel units in the Y direction
    @param sigmaX standard deviation of Gaussian in pixel units in the X direction
    
    """
    g = gaussKern(sigmaY, sigmaX,nSigma=nSigma)
    improc = convolve(im,g, mode='same')
    return improc

def gaussKern(sigmaY,sigmaX,nSigma=5.0):
    """
    @brief (C) copied from flipper
    @ brief Returns a normalized 2D gauss kernel array for convolutions
    ^
    | Y
    |
    ------>
    X 
    """
    sizeY = int(nSigma*sigmaY)
    sizeX = int(nSigma*sigmaX)
    
    y, x = scipy.mgrid[-sizeY:sizeY+1, -sizeX:sizeX+1]
    g = scipy.exp(-(x**2/(2.*sigmaX**2)+y**2/(2.*sigmaY**2)))
    return g / g.sum()


if __name__ == '__main__':
    
    main()
