#!/bin/env python

from fftTools import *
from liteMap import *
from optparse import OptionParser
import os

paramsPath = os.environ["FLIPPER_DIR"]
binFile = paramsPath + os.path.sep + "params" + os.path.sep + 'BIN_100_LOG'
theoryFile = os.environ["WMAP_DIR"] + os.path.sep + 'wmap_3year_toKevin_lensed_v3_lensedCls.dat'

if __name__=="__main__":

    usage = "simplePower -o outDir -l legendLabel -f yMultiplyer -b FWHM -m maskFile -n showNoise "\
            "-y '[minY,maxY]' -x '[minX,maxX]'"
    parser = OptionParser()
    parser.add_option("-o","--outdir",dest='outDir',default = None)
    parser.add_option("-l","--label",dest='figLabel',default='')
    parser.add_option("-f","--factor",dest='factor',default=1.0,type='float')
    parser.add_option("-b","--beam",dest = 'beamFWHM',default=1.4,type='float')
    parser.add_option("-m","--maskFile",dest = 'maskFile',default=None)
    parser.add_option("-n","--noise",dest = 'showNoise',default=False,action='store_true')
    parser.add_option("-y","--yrange",dest = 'yrange', default="None")
    parser.add_option("-L","--elrange",dest = 'elrange', default="None")
    
    (options,args) = parser.parse_args()
    
    file1 = args[0]
    file2 = args[1]

    yFactor = options.factor
    print "*********** %f **************"%yFactor
    saveplot = False
    tag = options.figLabel
    beamFWHM = options.beamFWHM
    applyMask = True
    if options.maskFile == None:
        applyMask = False
    
    showNoise = options.showNoise
    elrange = eval(options.elrange)
    yrange = eval(options.yrange)


    zoomUptoL = 3000
    if showNoise:
        zoomUptoL = 15000

    #theoryFile = 'SLAVED_BINNED_THEORY_BIN_2008FULL_TRIM_4000'
    #theoryFile = 'wmap_3year_toKevin_lensed_v3_lensedCls.dat'
    
    if options.outDir != None:
        figdir = options.outDir
        saveplot= True
    
    
    print "Processing File %s"%file1
    liteMap = liteMapFromFits(file1)
    fname = (file1.split('/'))[-1]
    
    if applyMask:
        mask = liteMapFromFits(options.maskFile)
        liteMap.data[:,:] *= mask.data[:,:]
        
    p2d00 = powerFromLiteMap(liteMap,applySlepianTaper=True)
    
    if not saveplot:
        p2d00.plot(show=True,log=True,zoomUptoL=zoomUptoL,title=fname)

    print "Processing File %s"%file2
    
    liteMap2 = liteMapFromFits(file2)
    
    
    if applyMask:
        mask = liteMapFromFits(options.maskFile)
        liteMap2.data[:,:] *= mask.data[:,:]
    
    fname2 = (file2.split('/'))[-1]
    p2d11 = powerFromLiteMap(liteMap2,applySlepianTaper=True)
    if not saveplot:
        p2d11.plot(show=True,log=True,zoomUptoL=zoomUptoL,title=fname2)

    #for errorbars we mutiply the two autopowers 
    p2d11.powerMap[:,:] *= p2d00.powerMap[:,:]
    #we create the vertical mask we are throwing out
    p2d11.createKspaceMask(verticalStripe=[-200,200])
    #we get the mean of this "power sqaured" thing
    lL,lU,lbinErr,plbinErrSq, junk,weightsErrSq = p2d11.binInAnnuli(binFile,cutByMask=True)
        
    
    p2d01 = powerFromLiteMap(liteMap,liteMap2,applySlepianTaper=True,nresForSlepian=2.0)
    if not saveplot:
        p2d01.plot(show=True,log=False,zoomUptoL=zoomUptoL,title=fname+'_x_'+fname2)
    
    p2d01.createKspaceMask(verticalStripe=[-40,40])
    #p2d01.divideByPixelWindow()
    lL,lU,lbin2,plbin2,plerr2,binWeights2 = p2d01.binInAnnuli( binFile, cutByMask=True)

    #now define the errorbars
    idx = numpy.where(weightsErrSq == 0)
    errorBarsFromAuto = numpy.sqrt((plbinErrSq+plbin2**2)/weightsErrSq)
    errorBarsFromAuto[idx] = 0.
    plerr2[:] = errorBarsFromAuto[:]

    
    if yrange == None:
        yrange = [0, 1200]
        if showNoise:
            yrange = [0,3000]
    if elrange == None:
        elrange = [0, 10000]
        if showNoise:
            elrange = [0, 14000]


            
    plbin0 = plbin2.copy()
    
    plotBinnedPower(lbin2,plbin2,\
                    title =  fname+'_x_'+fname2+'  '+tag,
                    theoryFile = theoryFile,\
                    yFactor = yFactor,\
                    yrange=yrange,\
                    maxL = elrange[1],\
                    minL = elrange[0],\
                    ylog=False,\
                    returnPlot= True,\
                    beamFWHM=beamFWHM,\
                    errorBars=errorBarsFromAuto,\
                    fitNoise=showNoise,\
                    noiseLabel=showNoise,\
                    color='red')
            
    pylab.legend()
    if not saveplot:
        pylab.show()
    else:
        pylab.savefig(figdir+'/PSCross_'+(fname.split('.'))[0]+'_x_'+(fname2.split('.'))[0]+tag+'Linear.png')
        numpy.savetxt(figdir+'/PSCross_'+(fname.split('.'))[0]+'_x_'+(fname2.split('.'))[0]+tag+".txt", [lbin2, plbin2, plerr2], fmt="%12.6G")
        pylab.save(figdir+'/PSCross_'+(fname.split('.'))[0]+'_x_'+(fname2.split('.'))[0]+tag+".table", (lbin2, plbin2, plerr2), fmt="%12.6G")
    pylab.clf()
    
    plotBinnedPower(lbin2,plbin0,\
                    title =  fname+'_x_'+fname2+'  '+tag,
                    theoryFile = theoryFile,\
                    yFactor = yFactor,\
                    yrange=[.1,1e6],\
                    maxL = elrange[1],\
                    ylog=True, returnPlot= True,\
                    beamFWHM=beamFWHM,\
                    errorBars=plerr2,\
                    fitNoise=showNoise,\
                    noiseLabel=showNoise,\
                    color='red')
    
    pylab.legend()
    if not saveplot:
        pylab.show()
    else:
        pylab.savefig(figdir+'/PSCross_'+(fname.split('.'))[0]+'_x_'+(fname2.split('.'))[0]+tag+'.png')
        
        
